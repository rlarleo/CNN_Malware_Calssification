
from flask import Flask, flash, request, redirect, jsonify, Response,send_file
from flask import url_for, render_template
from flask_cors import CORS
from werkzeug.utils import secure_filename
import io
import bytes_to_images
import grad_cam
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.models import Model
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from PIL import Image
import winpwn
import pymysql

app = Flask(__name__)
CORS(app, supports_credentials=True)

app.secret_key = 'random string'  # 프레임워크 상에서 꼭 넣으라고 요구함.
model = None

def load_model():
	# load the pre-trained Keras model
	global model
	model = tf.keras.models.load_model(
		"cnn_model", custom_objects=None, compile=True, options=None
	)

@app.route('/serverTest', methods=['GET'])
def hello():
	response = Response()
	response.set_data("서버 연결 상태 양호")
	return response

@app.route('/uploader', methods=['POST'])
def uploader():
	if request.method == 'POST':
		file = request.files['file']
		print(request.files['file'])
		filename=file.filename
		file.save("malware/" + filename)
		bytes_to_images.convert_to_images("malware", "images")

		print('파일 업로드 성공!!')
		return '파일 업로드 성공!!'

@app.route('/gradCAM', methods=['GET'])
def grad_cam():
	if request.method == 'GET':
		fileName = request.args.get('file')
		weights = model.layers[-1].get_weights()[0]
		model2 = Model(inputs=model.input, outputs=[model.layers[11].output, model.output])
		img = cv2.imread("imagesV2/malware/" + fileName + ".jpg")
		img_height = img.shape[0]
		img_width = img.shape[1]
		print('image height :', img_height)
		print('image width :', img_width)
		img = cv2.resize(img, (img_width, 2048))
		x = img.copy()
		x.astype(np.float32)
		x = x / 255.0
		[base_model_outputs, prediction] = model2.predict(np.expand_dims(x, axis=0))
		prediction = prediction[0]
		base_model_outputs = base_model_outputs[0]
		cam = (prediction - 0.5) * np.matmul(base_model_outputs, weights)
		cam -= cam.min()
		cam /= cam.max()
		cam -= 0.2
		cam /= 0.8

		cam = cv2.resize(cam, (img_width, 2048))
		heatmap = cv2.applyColorMap(np.uint8(255 * cam), cv2.COLORMAP_JET)
		fix_img = cv2.cvtColor(heatmap, cv2.COLOR_BGR2RGB)
		fix_img[np.where(cam <= 0.2)] = 0
		heatmap[np.where(cam <= 0.2)] = 0

		out = cv2.addWeighted(img, 0.8, heatmap, 0.4, 0)
		out3 = cv2.addWeighted(img, 0.8, fix_img, 0.4, 0)
		out3 = cv2.resize(out3, (img_width, img_height))
		myHeatmap = cv2.addWeighted(img, 0, heatmap, 1, 0)
		out2 = cv2.resize(myHeatmap, (img_width, img_height))

		np.save('heatmap.npy', out2)
		np.save('out3.npy', out3)

		test_datagen = ImageDataGenerator(rescale=1. / 255)
		testGenSet = test_datagen.flow_from_directory(
			"imagesV2",
			target_size=(2048, 256),
			color_mode="rgb",
			class_mode='categorical',
			batch_size=32,
		)

		predict_m = model.predict(testGenSet)
		classes_x = np.argmax(predict_m, axis=1)
		print(classes_x + 1)
		print(classes_x[0] +1)

		heatmapFile = np.load('heatmap.npy')
		img = Image.fromarray(heatmapFile)
		img.save('my.png')
		heatmapFile = np.load('out3.npy')
		img = Image.fromarray(heatmapFile)
		img.save('heatmap.png')
		heatmap = np.load('heatmap.npy')
		i = 0
		max_val = 0
		str_idx = 0
		end_idx = 0

		for h in heatmap:
			if (h[round(img_width/2)][2]) > max_val:
				max_val = h[round(img_width/2)][2]
				str_idx = i
			if (h[round(img_width/2)][2]) >= max_val:
				max_val = h[round(img_width/2)][2]
				end_idx = i
			i = i + 1

		print(str_idx)
		print(end_idx)

		return send_file('heatmap.png', mimetype='image/png')
	# + " str_idx = "+ str_idx + " end_idx = " + end_idx

@app.route('/byteCode', methods=['GET'])
def res_byteCode():
	if request.method == 'GET':
		fileName = request.args.get('file')

		weights = model.layers[-1].get_weights()[0]
		model2 = Model(inputs=model.input, outputs=[model.layers[11].output, model.output])
		img = cv2.imread("imagesV2/malware/" + fileName + ".jpg")
		img_height = img.shape[0]
		img_width = img.shape[1]
		print('image height :', img_height)
		print('image width :', img_width)
		img = cv2.resize(img, (img_width, 2048))
		x = img.copy()
		x.astype(np.float32)
		x = x / 255.0
		[base_model_outputs, prediction] = model2.predict(np.expand_dims(x, axis=0))
		prediction = prediction[0]
		base_model_outputs = base_model_outputs[0]

		cam = (prediction - 0.5) * np.matmul(base_model_outputs, weights)
		cam -= cam.min()
		cam /= cam.max()
		cam -= 0.2
		cam /= 0.8

		cam = cv2.resize(cam, (img_width, 2048))
		heatmap = cv2.applyColorMap(np.uint8(255 * cam), cv2.COLORMAP_JET)
		fix_img = cv2.cvtColor(heatmap, cv2.COLOR_BGR2RGB)
		fix_img[np.where(cam <= 0.2)] = 0
		heatmap[np.where(cam <= 0.2)] = 0

		out = cv2.addWeighted(img, 0.8, heatmap, 0.4, 0)
		out3 = cv2.addWeighted(img, 0.8, fix_img, 0.4, 0)
		out3 = cv2.resize(out3, (img_width, img_height))
		myHeatmap = cv2.addWeighted(img, 0, heatmap, 1, 0)
		out2 = cv2.resize(myHeatmap, (img_width, img_height))

		np.save('heatmap.npy', out2)
		np.save('out3.npy', out3)

		test_datagen = ImageDataGenerator(rescale=1. / 255)
		testGenSet = test_datagen.flow_from_directory(
			"imagesV2",
			target_size=(2048, 256),
			color_mode="rgb",
			class_mode='categorical',
			batch_size=32,
		)

		predict_m = model.predict(testGenSet)
		classes_x = np.argmax(predict_m, axis=1)
		print(classes_x + 1)
		print(classes_x[0] + 1)

		heatmap = np.load('heatmap.npy')
		i = 0
		max_val = 0
		str_idx = 0
		end_idx = 0
		exploit_class = int(classes_x[0] + 1)
		for h in heatmap:
			if (h[round(img_width/2)][2]) > max_val and h[round(img_width/2)][1] < 50:
				max_val = h[round(img_width/2)][2]
				str_idx = i
			if (h[round(img_width/2)][2]) >= max_val and h[round(img_width/2)][1] < 50:
				max_val = h[round(img_width/2)][2]
				end_idx = i
			i = i + 1


		print(img_width)
		str_idx = str_idx * (img_width/16)
		end_idx = end_idx * (img_width/16)
		print(str_idx)
		print(end_idx)
		response_data = {'strIdx': str_idx, 'endIdx': end_idx, 'exploitName': exploit_class}
		return jsonify(response_data)

@app.route('/opCode', methods=['GET'])
def res_opCode():
	filepath= request.args.get('file')
	print(filepath)
	str_idx = int(request.args.get('strIdx'))
	print(str_idx)
	end_idx = int(request.args.get('endIdx'))
	print(end_idx)
	f = open('malware/' + filepath)
	assemblyCode = ""
	index = 0;
	for line in f:
		if str_idx < index < end_idx:
			assemblyCode += winpwn.disasm(line, 0, "i386")
		index = index + 1
	f.close()
	response_data = {'opcode': assemblyCode}

	os.remove('imagesV2/malware/' + filepath + '.jpg')
	os.remove('malware/' + filepath)
	os.remove('heatmap.npy')
	os.remove('out3.npy')
	os.remove('heatmap.png')
	os.remove('my.png')
	return jsonify(response_data)

# if this is the main thread of execution first load the model and
# then start the server

if __name__ == '__main__':
	load_model()
	app.run(host='0.0.0.0', debug=True)

