import axios from "axios";
import {
  FILE_SEND_FAILURE,
  FILE_SEND_REQUEST,
  FILE_SEND_SUCCESS,
  BYTECODE_INDEX_REQUEST,
  BYTECODE_INDEX_SUCCESS,
  BYTECODE_INDEX_FAILURE,
  BYTE_TO_OPCODE_REQUEST,
  BYTE_TO_OPCODE_SUCCESS,
  BYTE_TO_OPCODE_FAILURE,
  SET_HEATMAP_REQUEST,
  SET_HEATMAP_SUCCESS,
  SET_HEATMAP_FAILURE,
} from "reducers/file";
import { all, call, fork, put, select, takeLatest } from "redux-saga/effects";

axios.defaults.baseURL = process.env.NEXT_PUBLIC_API_BASE_URL;

function fileSendAPI(data: File) {
  const form = new FormData();
  form.append("file", data);
  return axios.post(`/uploader`, form, {
    headers: {
      "Content-Type": "multipart/form-data",
    },
  });
}
function* fileSend(action: any) {
  try {
    const response = yield call(fileSendAPI, action.data.file);
    yield put({
      type: FILE_SEND_SUCCESS,
      data: response.data,
    });
    yield alert("파일 전송 완료!");
  } catch (err) {
    yield put({
      type: FILE_SEND_FAILURE,
      error: err,
    });
  }
}
function* watchFileSend() {
  yield takeLatest(FILE_SEND_REQUEST, fileSend);
}

function runGradCAMAPI(data) {
  return axios.get(`/gradCAM?file=${data.fileName}`, { headers: { responseType: "arraybuffer" } });
}
function* runGradCAM(action: any) {
  try {
    const response = yield call(runGradCAMAPI, action.data);
    yield put({
      type: SET_HEATMAP_SUCCESS,
      data: response.data,
    });

    yield put({
      type: BYTECODE_INDEX_REQUEST,
      data: { fileName: action.data.fileName },
    });
  } catch (err) {
    yield put({
      type: SET_HEATMAP_FAILURE,
      error: err,
    });
  }
}
function* watchRunGradCAM() {
  yield takeLatest(SET_HEATMAP_REQUEST, runGradCAM);
}
function getByteCodeAPI(data) {
  return axios.get(`/byteCode?file=${data.fileName}`);
}
function* getByteCode(action: any) {
  try {
    const response = yield call(getByteCodeAPI, action.data);
    let exploitName = "";
    if (response.data.exploitName) {
      switch (response.data.exploitName) {
        case 1:
          exploitName = "1. Ramnit";
          break;
        case 2:
          exploitName = "2. Lollipop";
          break;
        case 3:
          exploitName = "3.	Kelihos_ver3";
          break;
        case 4:
          exploitName = "4.	Vundo";
          break;
        case 5:
          exploitName = "5.	Simda";
          break;
        case 6:
          exploitName = "6.	Tracur";
          break;
        case 7:
          exploitName = "7.	Kelihos_ver1";
          break;
        case 8:
          exploitName = "8.	Obfuscator.ACY";
          break;
        case 9:
          exploitName = "9.	Gatak";
          break;
      }
    }
    yield put({
      type: BYTECODE_INDEX_SUCCESS,
      data: { ...response.data, exploitName: exploitName },
    });
    yield alert("op code를 확인하세요");
  } catch (err) {
    yield put({
      type: BYTECODE_INDEX_FAILURE,
      error: err,
    });
  }
}
function* watchGetByteCode() {
  yield takeLatest(BYTECODE_INDEX_REQUEST, getByteCode);
}
function byteToOPAPI(data) {
  return axios.get(`/opCode?file=${data.fileName}&strIdx=${data.strIdx}&endIdx=${data.endIdx}`);
}
function* byteToOP(action: any) {
  try {
    const response = yield call(byteToOPAPI, action.data);
    yield put({
      type: BYTE_TO_OPCODE_SUCCESS,
      data: response.data,
    });
    yield alert("op code 변환 및 수신 완료");
  } catch (err) {
    yield put({
      type: BYTE_TO_OPCODE_FAILURE,
      error: err,
    });
  }
}
function* watchByteToOp() {
  yield takeLatest(BYTE_TO_OPCODE_REQUEST, byteToOP);
}

export default function* File() {
  yield all([fork(watchFileSend), fork(watchGetByteCode), fork(watchRunGradCAM), fork(watchByteToOp)]);
}
